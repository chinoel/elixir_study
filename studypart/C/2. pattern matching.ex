# 패턴 매칭은 Elixir의 강력한 기능이죠
# 간단한 값, 자료 구조, 함수 등 다 매치시킬 수 있습니다.
# 근데 정신 나갈 수도 있는 구간이니 조심하세요

x = 1
IO.puts(x)

# 그저 x를 출력하는데 이제 이거 매칭 해보죠
IO.puts(1 = x)

# 어라? 뭔가 이상하지 않아요? 여캐껏 x에 1을 주입한 줄 알았는데,,
# 왜 1 = x 가 되버리면 1에 x를 주입하는걸까요?
# 근데 왜 오류가 안나요? 정수인데??
# 안되겠어요 2를 넣어봐야겠어요

# IO.puts(2 = x)
# 이건 왜.. MatchError) no match of right hand side value: 1....
# 왜죠? 이상하지 않나요?! 2에 x를 넣을 수도 있는데?!!

# 이건 Elixir의 패턴 매칭이기 때문이에요.
# 패턴 매칭은 좌변과 우변을 비교하는데, 좌변이 우변에 맞춰지면 성공이에요.
# 근데 좌변이 우변에 맞춰지면 성공이니까, 좌변에 있는 x는 우변의 1로 대체되죠.
# 그래서 x는 1이 되고, 2 = x는 실패해요.
# 리스트로 보면 더 이해가 잘되죠
list = [1, 2, 3]
IO.inspect([1, 2, 3] = list)
# IO.inspect([] = list)

# 뭐... 이걸로 저희는 패턴 매칭을 이해했어요.
# 튜플에서도 해볼까요?
{:ok, value} = {:ok, "Successful!"}
IO.puts(value)
# {:ok, value} = {:error}

# 이러면 MatchError가 발생해요.
# 왜냐면 좌변의 :ok는 우변의 :error와 매칭이 안되니까요.
# 어려운 게 당연한 부분입니다. 기존 자바나 다른 언어와는 다르니까요.
# 그래도 패턴 매칭은 Elixir의 강력한 기능이죠

# 이제 핀 연산자로 가보죠
x = 1
# ^x = 2
# 어라? 이건 값 대입이잖아요. 왜 오류가 나죠..?
# 핀 연산자는 패턴 매칭에서 변수를 고정하는데 사용돼요.
# 핀 연산자를 사용하면 변수를 고정할 수 있어요. 즉, 변수의 값을 변경할 수 없죠.

key = "hello"
IO.inspect(%{^key => value} = %{"hello" => "world"})
IO.inspect(value) # world

# IO.inspect(%{^key => value} = %{:hello => "world"})
# 뭐 이건 당연히 오류 나겠죠
# 왜냐면 키가 다르니까요.

# 이 정도 따라온다면 제어 구조로 가셔도됩니다.
